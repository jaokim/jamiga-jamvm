
#include "signal.h"

extern void proxyExceptionHandler(struct Library * SysBase, int signals, struct sigaction *exceptData);
extern void realAmigaExit(int error);

/**
 * sigprocmask
 *
 * In a single-threaded process, the sigprocmask() function allows the calling
 * process to examine or change (or both) the signal mask of the calling thread.
 *
 * If the argument set is not a null pointer, it points to a set of signals to be
 * used to change the currently blocked set.
 * The argument how indicates the way in which the set is changed, and consists
 * of one of the following values:
 *
 * SIG_BLOCK
 *   The resulting set will be the union of the current set and the signal set
 *   pointed to by set.
 * SIG_SETMASK
 *   The resulting set will be the signal set pointed to by set.
 * SIG_UNBLOCK
 *   The resulting set will be the intersection of the current set and the complement
 *   of the signal set pointed to by set.
 *
 * If the argument oset is not a null pointer, the previous mask is stored in the
 * location pointed to by oset. If set is a null pointer, the value of the argument
 * how is not significant and the process' signal mask is unchanged; thus the call
 * can be used to enquire about currently blocked signals.
 *
 * If there are any pending unblocked signals after the call to sigprocmask(), at
 * least one of those signals will be delivered before the call to sigprocmask()
 * returns.
 *
 * It is not possible to block those signals which cannot be ignored. This is
 * enforced by the system without causing an error to be indicated.
 *
 * If any of the SIGFPE, SIGILL, SIGSEGV or SIGBUS signals are generated while they
 * are blocked, the result is undefined, unless the signal was generated by a function
 * capable of sending a signal to a specific process or thread.
 *
 * If sigprocmask() fails, the thread's signal mask is not changed.
 *
 * The use of the sigprocmask() function is unspecified in a multi-threaded process.
 *
 * The pthread_sigmask() function is used to examine or change (or both) the calling
 * thread's signal mask, regardless of the number of threads in the process. The
 * effect is the same as described for sigprocmask(), without the restriction that the
 * call be made in a single-threaded process.
 *
 */
void sigprocmask(int blocktype, uint32 * mask_ptr, void *unused1) {
    /*struct PthreadInitData * initData = GetExitData();
    if(initData == NULL) {
        JA_TRACE("InitData is nuLL!!!\n");
        return;
    }
    JA_TRACE("Called sigprocmask %s mask:%lx\n", (blocktype == SIG_UNBLOCK?"UNBLOCK (catch signals) ":"BLOCK (ignore signal)"), (*mask_ptr));
    // sigkill is handled by our own exceptio handler
    sigaddset(mask_ptr, SIGKILL);
    sigaddset(mask_ptr, SIGINT);

    initData->pd_SigMask = blocktype == SIG_UNBLOCK ? (*mask_ptr) : 0;
    SetExcept(blocktype == SIG_UNBLOCK ? (*mask_ptr) : ((1<<SIGINT)&(1<<SIGKILL)),blocktype == SIG_UNBLOCK ? (*mask_ptr) : ((1<<SIGINT)&(1<<SIGKILL)));//(*mask_ptr));
    */
    uint32 old_signals, new_signals = 0, current_signals;
    //JA_TRACE("Called pthread_sigmask %s mask:%lx sigkill: %lx\n", (blocktype == SIG_UNBLOCK?"UNBLOCK (catch signals) ":"BLOCK (ignore signal)"), (*mask_ptr), (1<<SIGKILL));
    //struct PthreadInitData * initData = GetExitData();
    old_signals = SetExcept(0,0);

    switch(blocktype) {
        case SIG_BLOCK:
            JA_TRACE("SIG_BLOCK\n");
            new_signals = (*mask_ptr) & old_signals;//0

            break;
        case SIG_UNBLOCK:
            JA_TRACE("SIG_UNBLOCK\n");
            new_signals = old_signals | (~(*mask_ptr));//(*mask_ptr);
            break;

        case SIG_SETMASK:
            JA_TRACE("SIG_SETMASK\n");
            new_signals = (*mask_ptr);
            // unused by jamvm
            break;

    }
    sigaddset(&new_signals, SIGKILL);
    sigaddset(&new_signals, SIGINT);
    current_signals = SetExcept(0,0);
    JA_TRACE("CurSignals: "BYTETOBINARYPATTERN, BYTETOBINARY((*mask_ptr)));
    JA_TRACE("CurSignals: "BYTETOBINARYPATTERN, BYTETOBINARY(current_signals));
    JA_TRACE("OldSignals: "BYTETOBINARYPATTERN, BYTETOBINARY(old_signals));
    JA_TRACE("NewSignals: "BYTETOBINARYPATTERN, BYTETOBINARY(new_signals));
    JA_TRACE("SIGKILL is %s, SIGINT is %s\n", sigismember(&new_signals, SIGKILL)?"set":"not set",  sigismember(&new_signals, SIGINT)?"set":"not set");
    //initData->pd_SigMask = new_signals;
    /*
    initData->pd_SigMask = blocktype == SIG_UNBLOCK ? *mask_ptr : 0;
    SetExcept(blocktype == SIG_UNBLOCK ? *mask_ptr : ((1<<SIGINT)&(1<<SIGKILL)),blocktype == SIG_UNBLOCK ? *mask_ptr : ((1<<SIGINT)&(1<<SIGKILL)));// *mask_ptr);
    */
    SetExcept(current_signals,new_signals);
}


/**
 * sigsuspend
 * sigsuspend() temporarily replaces the signal mask of the calling
 * process with the mask given by mask and then suspends the process
 * until delivery of a signal whose action is to invoke a signal handler
 * or to terminate a process.
 *
 * If the signal terminates the process, then sigsuspend() does not
 * return.  If the signal is caught, then sigsuspend() returns after the
 * signal handler returns, and the signal mask is restored to the state
 * before the call to sigsuspend().
 *
 * It is not possible to block SIGKILL or SIGSTOP; specifying these
 * signals in mask, has no effect on the process's signal mask.
 */

 /*
 http://chinki-singh.blogspot.se/2012/06/sigsuspend-vs-pause.html
   A small difference between these functions is that, in sigsuspend,
   we can specify the signal mask to which the function should not
   listen. Suppose we implement the sigsuspend in the following manner

    sigset_t tempmask;
    sigemptyset(&tempmask);
    sigaddset(&tempmask,SIGINT);
    sigsuspend(&tempmask);

   Now, in the above code, we have specified the sigsuspend function to
   listen for every signal except SIGINT.

   When sigsuspend receives any other signal than SIGINT, it returns.
   It shopuld return on SIGINT
 */
 /*
   called like this:
   -----
    sigfillset(&mask);
    sigdelset(&mask, SIGUSR1);
    sigdelset(&mask, SIGTERM);
    JA_TRACE("in suspendloop threadSelf: %lx %s old_state=%d\n", thread, thread->suspend?"thread->suspend":"!thread->suspend", old_state);
    while(thread->suspend && old_state == SUSP_NONE) {
        JA_TRACE("Calling sigsuspend\n")
        sigsuspend(&mask);
    }
   -----
   It should return on all but SIGUSR1 SIGTERM
    Now, in the above code, we have specified the sigsuspend function to
   listen for every signal except anything BUT SIGUSR1 and SIGTERM.

   When sigsuspend receives any other signal than all BUT SIGUSR1 and SIGTERM, it returns.

 */
 // listen to all except sugusr1 sigterm
 // wait for all except sigusr1 sigterm
 // if got them -> return
void sigsuspend(uint32 * maskptr) {
    uint32 signal = 0L;
    uint32 prevsigset = 0L;
    sigset_t all_sigs;
    sigfillset(&all_sigs);

    //sigaddset(maskptr, SIGKILL);
    //sigaddset(maskptr, SIGINT);
    //sigaddset(maskptr, SIGUSR1);
    JA_TRACE("sigsuspend:  maskptr %8lx: "BYTETOBINARYPATTERN, *maskptr, BYTETOBINARY(*maskptr));
    JA_TRACE("sigsuspend: ~maskptr %8lx: "BYTETOBINARYPATTERN, ~(*maskptr), BYTETOBINARY(~(*maskptr)));

    // Block sigint and sigkill from triggering exception

    JA_TRACE("sigsuspend (SetExcept): to 0L (maskptr: %lx)\n",*maskptr);
    // set all removed from maskptr to 0
    //                         1111110101
    prevsigset = SetExcept(0L,all_sigs);//~(*maskptr));
    JA_TRACE("sigsuspend (Wait     ): SIGKILL,  %lx\n",~(*maskptr));

    // wait for all signals removed from SetExcept
    signal = Wait(all_sigs);

    JA_TRACE("sigsuspendt: got: "BYTETOBINARYPATTERN, BYTETOBINARY(signal));
    if((signal & (1<<SIGKILL))==(1<<SIGKILL)) {
        JA_TRACE("sigsuspendt: got SIGKILL %lx\n", signal);
    }
    if((signal & ~(*maskptr))==0) {
        JA_TRACE("sigsuspendt: got this: %lx, returning\n", signal);
        //return;
    } else {
        JA_TRACE("sigsuspendt: got other: %lx\n", signal);

    }
    JA_TRACE("sigsuspend (wait): got signal %lx\n", signal);
    //JA_TRACE("sigsuspend SetSignal: now:%ld before: %ld\n", signal, *mask_ptr);
    //SetSignal(signal, signal);
    JA_TRACE("sigsuspend (setsignal): SIGKILL, not: %lx\n",*maskptr);
    JA_TRACE("sigsuspend (setexcept): SIGKILL, not: %lx\n",*maskptr);
    signal = SetExcept(prevsigset,prevsigset);
    //J/A_TRACE("sigsuspend calling detachThread\n");
    //detachThread(threadSelf());
    //JA_TRACE("sigsuspend remtask\n");
    //RemTask(0L);
    JA_TRACE("sigsuspend returns!\n");
    //SuspendTask(0, 0);//STF_REMOVED);
    
}


/**
 * sigaction
 *   Called like this from thread.c:
 *   act.sa_handler = suspendHandler;
 *   // sa_mask additional se to fl flags to be blocked during execution of signal cathcing func
 *   sigemptyset(&act.sa_mask);
 *   act.sa_flags = SA_RESTART;
 *   sigaction(SIGUSR1, &act, NULL);
 *
 * We need to store the sig and connect it to the sa_handler
 */

void sigaction(uint32 sig, struct sigaction * act, void *unused) {
    sigset_t mask;
    struct sigaction * newAct;
    sigemptyset(&mask);
    sigaddset(&mask, sig); 
    // sigkill is handled by our own exceptio handler
    sigaddset(&mask, SIGKILL);
    struct Task * task = FindTask(NULL);
    struct PthreadInitData * initData = GetExitData();
    JA_TRACE("sigaction ALLOCATED STUFF %ld\n", sig);
    newAct = task->tc_ExceptData; //
    newAct->sa_handler = act->sa_handler;
    newAct->sa_flags = act->sa_flags;
    newAct->sa_mask = act->sa_mask;
    //newAct;//&((struct sigaction*)act)->sa_handler;
    task->tc_ExceptCode = &proxyExceptionHandler;///&((struct sigaction*)act)->sa_handler;
    // sigkill is handled by our own exceptio handler
    //initData->pd_SigMask = mask;
    //SetExcept(mask, 0);
}

/**
 * sigwait
 */
void sigwait(uint32 * maskptr, uint32 * sigptr) {
    uint32 retSigMask;
    JA_TRACE("sigwait: %lx\n",*maskptr);
    // disable setExcept for the signals waiting oin here.. rght?
    //originalSignals = SetExcept(0,0);

    retSigMask = Wait(*maskptr);
    (*sigptr) = 0;
    uint32 i = 1, j=0;
    while(i <= 32) {
        //JA_TRACE("sigwait: Cheking: %ld %ld %ld\n",i, 1<<i, retSigMask);
        // What happens when we have two signals...?
        if(((1<<i) & retSigMask) == (1<<i)) {
            //JA_TRACE("sigwait: Returning: %ld\n", i);
            (*sigptr) = i;
            break;
        }   
        i++;
    }
    JA_TRACE("sigwait: done: %lx\n",*sigptr);
}


/**
 * sigsetjmp()
 * A call to sigsetjmp() saves the calling environment in its env argument
 * for later use by siglongjmp(). It is unspecified whether sigsetjmp() is a
 * macro or a function. If a macro definition is suppressed in order to access
 * an actual function, or a program defines an external identifier with the
 * name sigsetjmp the behaviour is undefined.
 * If the value of the savemask argument is not 0, sigsetjmp() will also save
 * the current signal mask of the calling thread as part of the calling environment.
 *
 * All accessible objects have values as of the time siglongjmp() was called,
 * except that the values of objects of automatic storage duration which are
 * local to the function containing the invocation of the corresponding sigsetjmp()
 * which do not have volatile-qualified type and which are changed between the
 * sigsetjmp() invocation and siglongjmp() call are indeterminate.
 *
 * An invocation of sigsetjmp() must appear in one of the following contexts only:
 *
 * -  the entire controlling expression of a selection or iteration statement
 * -  one operand of a relational or equality operator with the other operand an integral
 *      constant expression, with the resulting expression being the entire controlling
 *      expression of a selection or iteration statement
 * -  the operand of a unary (!) operator with the resulting expression being the entire
 *      controlling expression of a selection or iteration
 * -  the entire expression of an expression statement (possibly cast to void).
 *
 * RETURN VALUE
 *    If the return is from a successful direct invocation, sigsetjmp() returns 0. If the
 *    return is from a call to siglongjmp(), sigsetjmp() returns a non-zero value.
 */
/*
    sigsetjmp is called from suspendLoop() in thread.c
    I think the idea is to save the top of the stack:

        suspendLoop() {
            ...
            sigsetjmp(env, FALSE);
            thread->stack_top = &env;
            ...
        }
        void *getStackTop(Thread *thread) {
            return thread->stack_top;
        }

    Meanwhile, in alloc.c:

        void scanThread(Thread *thread) {
            ...
            uintptr_t *end, *slot;

            TRACE_GC("Scanning stacks for thread %p id %d\n", thread, thread->id);

            slot = (uintptr_t*)getStackTop(thread);
            end = (uintptr_t*)getStackBase(thread);

            for(; slot < end; slot++)
                if(IS_OBJECT(*slot)) {
                    Object *ob = (Object*)*slot;
                    TRACE_GC("Found C stack ref @%p object ref is %p\n", slot, ob);
                    markConservativeRoot(ob);
                }
            }
            ...
        }

    So: this is only used for the GC -- can be ignored, for now.
    // COME BACK!
 */
int sigsetjmp(sigjmp_buf env, int savemask) {
    //struct ExceptionContext ec;
    //JA_TRACE("Should've called sigsetjmp\n");
    return 0;
}

